{"config":{"indexing":"full","lang":["en"],"min_search_length":3,"prebuild_index":false,"separator":"[\\s\\-]+"},"docs":[{"location":"","text":"Kohii \u00b6 kohii (\u30b3\u30fc\u30d2\u30fc\u3001 [ko\u031e\u02d0\u00e7i\u02d0] ) \u00b6 Video playback for Android made easy. Kohii is a powerful, extensible, yet easy to use and extensible Video playback library. Kohii provides useful features out of the box, including Easy to start: just one line to start a Video playback. Automatic playback experience on RecyclerView, NestedScrollView, ViewPager2, etc. Configuration change handling works out of the box, including the switching from in-list player to fullscreen player and vice versa. Feature-rich sample app that covers either simple or advance use cases. Extensible, including default implementations that support ExoPlayer, AndroidX Media2, YouTube Player SDK. Demo \u00b6 Automatic playback Playback continuity (Seamless fullscreen) Setup \u00b6 Add to your module's build.gradle dependencies // Update top level build.gradle allprojects { repositories { mavenCentral () } } // Add these to app level build.gradle (or to module that will use Kohii) def kohiiVersion = '1.4.0.2017001' def exoPlayerVersion = '2.17.1' implementation \"im.ene.kohii:kohii-core:${kohiiVersion}\" implementation \"im.ene.kohii:kohii-exoplayer:${kohiiVersion}\" implementation \"com.google.android.exoplayer:exoplayer:${exoPlayerVersion}\" Start a playback \u00b6 Assuming that you have a Fragment which contains a RecyclerView , and you want to play a Video using a PlayerView placed inside a ViewHolder of the RecyclerView , below is what you need to do using Kohii : Kotlin // Kotlin // TODO: Have a videoUrl first. // 1. Initialization in Fragment val kohii = Kohii [ this @Fragment ] kohii . register ( this @Fragment ). addBucket ( this . recyclerView ) // 2. In ViewHolder or Adapter: bind the video to the PlayerView. kohii . setUp ( videoUrl ). bind ( playerView ) Java // Java // TODO: Have a videoUrl first. // 1. Initialization in Fragment Kohii kohii = Kohii . get ( this ); kohii . register ( this ). addBucket ( this . recyclerView ); // 2. In ViewHolder or Adapter: bind the video to the PlayerView. kohii . setUp ( videoUrl ). bind ( playerView ); Requirements \u00b6 Kohii works on Android 4.4+ (API level 19+) and on Java 8+. It is recommended to use Kohii using the Kotlin\u2122 language. The core library doesn't come with any actual playback logic. Actual implementation comes with extension libraries. The extensions require corresponding 3 rd libraries: kohii-exoplayer will require exoplayer , kohii-androidx will require androidx.media2 .","title":"Overview"},{"location":"#kohii","text":"","title":"Kohii"},{"location":"#kohii-koci","text":"Video playback for Android made easy. Kohii is a powerful, extensible, yet easy to use and extensible Video playback library. Kohii provides useful features out of the box, including Easy to start: just one line to start a Video playback. Automatic playback experience on RecyclerView, NestedScrollView, ViewPager2, etc. Configuration change handling works out of the box, including the switching from in-list player to fullscreen player and vice versa. Feature-rich sample app that covers either simple or advance use cases. Extensible, including default implementations that support ExoPlayer, AndroidX Media2, YouTube Player SDK.","title":"kohii (\u30b3\u30fc\u30d2\u30fc\u3001[ko\u031e\u02d0\u00e7i\u02d0])"},{"location":"#demo","text":"Automatic playback Playback continuity (Seamless fullscreen)","title":"Demo"},{"location":"#setup","text":"Add to your module's build.gradle dependencies // Update top level build.gradle allprojects { repositories { mavenCentral () } } // Add these to app level build.gradle (or to module that will use Kohii) def kohiiVersion = '1.4.0.2017001' def exoPlayerVersion = '2.17.1' implementation \"im.ene.kohii:kohii-core:${kohiiVersion}\" implementation \"im.ene.kohii:kohii-exoplayer:${kohiiVersion}\" implementation \"com.google.android.exoplayer:exoplayer:${exoPlayerVersion}\"","title":"Setup"},{"location":"#start-a-playback","text":"Assuming that you have a Fragment which contains a RecyclerView , and you want to play a Video using a PlayerView placed inside a ViewHolder of the RecyclerView , below is what you need to do using Kohii : Kotlin // Kotlin // TODO: Have a videoUrl first. // 1. Initialization in Fragment val kohii = Kohii [ this @Fragment ] kohii . register ( this @Fragment ). addBucket ( this . recyclerView ) // 2. In ViewHolder or Adapter: bind the video to the PlayerView. kohii . setUp ( videoUrl ). bind ( playerView ) Java // Java // TODO: Have a videoUrl first. // 1. Initialization in Fragment Kohii kohii = Kohii . get ( this ); kohii . register ( this ). addBucket ( this . recyclerView ); // 2. In ViewHolder or Adapter: bind the video to the PlayerView. kohii . setUp ( videoUrl ). bind ( playerView );","title":"Start a playback"},{"location":"#requirements","text":"Kohii works on Android 4.4+ (API level 19+) and on Java 8+. It is recommended to use Kohii using the Kotlin\u2122 language. The core library doesn't come with any actual playback logic. Actual implementation comes with extension libraries. The extensions require corresponding 3 rd libraries: kohii-exoplayer will require exoplayer , kohii-androidx will require androidx.media2 .","title":"Requirements"},{"location":"advance-builder/","text":"Using Builder \u00b6 Kohii instance can be constructed using Builder . By default, calling Kohii[context] will create or reuse an instance with default implementation. For advance users, it is more flexible to be able to customize this. Kohii provides Builder to make this happen: Kotlin val playableCreator = MyCustomPlayableCreator () val builder = Kohii . Builder ( context ) . setPlayableCreator ( playableCreator ) val kohii = builder . build () Java PlayableCreator < PlayerView > playableCreator = new MyCustomPlayableCreator (); Kohii . Builder builder = new Kohii . Builder ( context ) . setPlayableCreator ( playableCreator ); Kohii kohii = builder . build (); If you still want to use the default PlayerViewPlayableCreator , it can be constructed by its own Builder too, which will requires a PlayerViewBridgeCreatorFactory which is of type (Context) -> BridgeCreator<PlayerView> : Kotlin val playableCreator : PlayableCreator < PlayerView > = PlayerViewPlayableCreator . Builder ( this ) . setBridgeCreatorFactory ( myFactory ). build () A full Kohii example: Kotlin val kohii = Kohii . Builder ( context ) . setPlayableCreator ( PlayerViewPlayableCreator . Builder ( context ) . setBridgeCreatorFactory { PlayerViewBridgeCreator ( myPlayerProvider , myMediaSourceFactoryProvider ) } . build () ) . setRendererProviderFactory ( myFactory ) . build () Please take a look at the source for all available builder parameters. Using extension methods \u00b6 From v1.1.0.2011003 You also have more advance ways to construct new Kohii instance: Kotlin val kohii = createKohii ( context = context , config = ExoPlayerConfig . DEFAULT ) Where ExoPlayerConfig is the combination of many base parameters to construct ExoPlayer's components like the LoadControl , DefaultTrackSelector , DefaultBandwidthMeter , etc. If you have existing parameter to reuse, you can use this convenient to build a Kohii instance using them. ExoPlayerConfig.DEFAULT is the default configuration where the parameters are the same as default ExoPlayer's setup. If you want to reuse the already-built ExoPlayer components ( LoadControl , DefaultTrackSelector , DefaultBandwidthMeter , etc) instead, you can also use the second convenient creator below: Kotlin val kohii = createKohii ( context = context , playerCreator = myPlayerCreator , mediaSourceFactoryCreator = myMediaSourceFactoryCreator , rendererProviderFactory = myFactory ) Using this method, you can pass your custom way of creating a new Player instance, MediaSourceFactory instance and RendererProvider instance. Each parameter comes with a default value.","title":"Using custom Kohii creators"},{"location":"advance-builder/#using-builder","text":"Kohii instance can be constructed using Builder . By default, calling Kohii[context] will create or reuse an instance with default implementation. For advance users, it is more flexible to be able to customize this. Kohii provides Builder to make this happen: Kotlin val playableCreator = MyCustomPlayableCreator () val builder = Kohii . Builder ( context ) . setPlayableCreator ( playableCreator ) val kohii = builder . build () Java PlayableCreator < PlayerView > playableCreator = new MyCustomPlayableCreator (); Kohii . Builder builder = new Kohii . Builder ( context ) . setPlayableCreator ( playableCreator ); Kohii kohii = builder . build (); If you still want to use the default PlayerViewPlayableCreator , it can be constructed by its own Builder too, which will requires a PlayerViewBridgeCreatorFactory which is of type (Context) -> BridgeCreator<PlayerView> : Kotlin val playableCreator : PlayableCreator < PlayerView > = PlayerViewPlayableCreator . Builder ( this ) . setBridgeCreatorFactory ( myFactory ). build () A full Kohii example: Kotlin val kohii = Kohii . Builder ( context ) . setPlayableCreator ( PlayerViewPlayableCreator . Builder ( context ) . setBridgeCreatorFactory { PlayerViewBridgeCreator ( myPlayerProvider , myMediaSourceFactoryProvider ) } . build () ) . setRendererProviderFactory ( myFactory ) . build () Please take a look at the source for all available builder parameters.","title":"Using Builder"},{"location":"advance-builder/#using-extension-methods","text":"From v1.1.0.2011003 You also have more advance ways to construct new Kohii instance: Kotlin val kohii = createKohii ( context = context , config = ExoPlayerConfig . DEFAULT ) Where ExoPlayerConfig is the combination of many base parameters to construct ExoPlayer's components like the LoadControl , DefaultTrackSelector , DefaultBandwidthMeter , etc. If you have existing parameter to reuse, you can use this convenient to build a Kohii instance using them. ExoPlayerConfig.DEFAULT is the default configuration where the parameters are the same as default ExoPlayer's setup. If you want to reuse the already-built ExoPlayer components ( LoadControl , DefaultTrackSelector , DefaultBandwidthMeter , etc) instead, you can also use the second convenient creator below: Kotlin val kohii = createKohii ( context = context , playerCreator = myPlayerCreator , mediaSourceFactoryCreator = myMediaSourceFactoryCreator , rendererProviderFactory = myFactory ) Using this method, you can pass your custom way of creating a new Player instance, MediaSourceFactory instance and RendererProvider instance. Each parameter comes with a default value.","title":"Using extension methods"},{"location":"advance-manual-playback/","text":"Document pending","title":"Manual playback (experimental)"},{"location":"advance-memory-mode/","text":"Using MemoryMode to improve UX \u00b6 Your screen may contain many Videos at a time, and preload Videos forward so they can start as soon as possible is a legit requirement. In practice, preloading Videos consumes a lot of system resource like memory, network and power. To address this need in proper way, Kohii provides a special control flag called MemoryMode . The idea behinds MemoryMode is as below: The idea is to allow Kohii to preload around Video of interest 1 . When the Video of interest is playing, at the same time Kohii will prepare the closet Videos around it: the first on top, the first below, the first to the left and/or the first to the right, and the second closet Videos, etc ... To control the maxinum number of Videos to prepare, Kohiii needs client to explixitly define this (with a default behavior to be automatic). MemoryMode is the information client uses to define this behavior. To use it, you need to update the code as below: - kohii.register(this) + kohii.register(this, MemoryMode.BALANCED) While allowing client to define this behavior, Kohii will strictly observe system memory status, and will override that behavior on demand to prevent your app from behaving unexpectedly. The Video that is selected to play \u21a9","title":"Using MemoryMode"},{"location":"advance-memory-mode/#using-memorymode-to-improve-ux","text":"Your screen may contain many Videos at a time, and preload Videos forward so they can start as soon as possible is a legit requirement. In practice, preloading Videos consumes a lot of system resource like memory, network and power. To address this need in proper way, Kohii provides a special control flag called MemoryMode . The idea behinds MemoryMode is as below: The idea is to allow Kohii to preload around Video of interest 1 . When the Video of interest is playing, at the same time Kohii will prepare the closet Videos around it: the first on top, the first below, the first to the left and/or the first to the right, and the second closet Videos, etc ... To control the maxinum number of Videos to prepare, Kohiii needs client to explixitly define this (with a default behavior to be automatic). MemoryMode is the information client uses to define this behavior. To use it, you need to update the code as below: - kohii.register(this) + kohii.register(this, MemoryMode.BALANCED) While allowing client to define this behavior, Kohii will strictly observe system memory status, and will override that behavior on demand to prevent your app from behaving unexpectedly. The Video that is selected to play \u21a9","title":"Using MemoryMode to improve UX"},{"location":"advance-multiple-playbacks/","text":"Playing many Videos at the same time \u00b6 Available from v1.1.0.2011003 From v1.1.0.2011003, Kohii adds Playback Selector and Playback Strategy to support multiple playbacks. The Selector is a Single Abstract Method that accepts a collection of candidate (= the Playbacks that can play the media) and returns a collection of Playback that should play the media. This feature is enabled at Bucket level. Which means that: client can have multiple playbacks in a Bucket by using correct Strategy and Selector . The setup is easy: you can set the Strategy and Selector at the time you add the Bucket . Kotlin kohii . register ( this ) . addBucket ( view = recyclerView , strategy = Strategy . MULTI_PLAYER , selector = { candidates -> candidates . take ( 2 ) } ) The code above will: add a new Bucket for the recyclerView , with MULTI_PLAYER Strategy and using a Selector that will select up to 2 Playbacks from the candidates to play. Note that, Strategy and Selector need to be set together to enable the multiple playbacks. If the client uses a Selector that selects many Playbacks, but uses the SINGLE_PLAYER Strategy, it will only play one Playback. The available Strategies are: MULTI_PLAYER : play all Playbacks selected by the Selector . SINGLE_PLAYER : play the first available Playback from the list selected by the Selector . NO_PLAYER : do not let the Selector select anything. NOTE : Multiple playbacks comes with a caveat. In Video playback, audio focus is an important aspect. The client needs to not only respect the audio focus given by system, but also to respect the audio focuses among a Video with the others in the same Application. Therefore, when the client enable MULTI_PLAYER Strategy , the library will forcefully mute the audio of all available Playbacks, regardless the number of Playbacks selected by the Selector . Changing to SINGLE_PLAYER or NO_PLAYER Strategy will switch everything back to normal.","title":"Multiple playbacks"},{"location":"advance-multiple-playbacks/#playing-many-videos-at-the-same-time","text":"Available from v1.1.0.2011003 From v1.1.0.2011003, Kohii adds Playback Selector and Playback Strategy to support multiple playbacks. The Selector is a Single Abstract Method that accepts a collection of candidate (= the Playbacks that can play the media) and returns a collection of Playback that should play the media. This feature is enabled at Bucket level. Which means that: client can have multiple playbacks in a Bucket by using correct Strategy and Selector . The setup is easy: you can set the Strategy and Selector at the time you add the Bucket . Kotlin kohii . register ( this ) . addBucket ( view = recyclerView , strategy = Strategy . MULTI_PLAYER , selector = { candidates -> candidates . take ( 2 ) } ) The code above will: add a new Bucket for the recyclerView , with MULTI_PLAYER Strategy and using a Selector that will select up to 2 Playbacks from the candidates to play. Note that, Strategy and Selector need to be set together to enable the multiple playbacks. If the client uses a Selector that selects many Playbacks, but uses the SINGLE_PLAYER Strategy, it will only play one Playback. The available Strategies are: MULTI_PLAYER : play all Playbacks selected by the Selector . SINGLE_PLAYER : play the first available Playback from the list selected by the Selector . NO_PLAYER : do not let the Selector select anything. NOTE : Multiple playbacks comes with a caveat. In Video playback, audio focus is an important aspect. The client needs to not only respect the audio focus given by system, but also to respect the audio focuses among a Video with the others in the same Application. Therefore, when the client enable MULTI_PLAYER Strategy , the library will forcefully mute the audio of all available Playbacks, regardless the number of Playbacks selected by the Selector . Changing to SINGLE_PLAYER or NO_PLAYER Strategy will switch everything back to normal.","title":"Playing many Videos at the same time"},{"location":"advance-reuse-renderer-instance/","text":"Reuse PlayerView instance for multiple Videos \u00b6 Until now, the setup code is always kohii.setUp(videoUrl).bind(playerView) which may let you think that you will need to bind the Video to a PlayerView instance. In Kohii , target of the method bind is called container . While PlayerView is the place where Video content is rendered (and therefore it is called renderer , it can also be a container which contains itself ). You can bind the Video to any ViewGroup as container, as long as either it is a renderer itself, or it has no children so that it can contain a renderer later. When you bind to a non-renderer container , for example an empty FrameLayout , Kohii will automatically prepare and add the PlayerView instance to that FrameLayout dynamically. At the same time, the unnecessary PlayerView instance will be removed from container and put back to a Pool . This way, only a few PlayerView instances will be created and reused for as many container/Videos as possible. By default, Kohii has its own logic for creating and recycling PlayerView , but developers can build their own by extending Engine - another important component of Kohii . Extending Engine and building custom playback logic will be discussed in topics for developers.","title":"Reusing renderer"},{"location":"advance-reuse-renderer-instance/#reuse-playerview-instance-for-multiple-videos","text":"Until now, the setup code is always kohii.setUp(videoUrl).bind(playerView) which may let you think that you will need to bind the Video to a PlayerView instance. In Kohii , target of the method bind is called container . While PlayerView is the place where Video content is rendered (and therefore it is called renderer , it can also be a container which contains itself ). You can bind the Video to any ViewGroup as container, as long as either it is a renderer itself, or it has no children so that it can contain a renderer later. When you bind to a non-renderer container , for example an empty FrameLayout , Kohii will automatically prepare and add the PlayerView instance to that FrameLayout dynamically. At the same time, the unnecessary PlayerView instance will be removed from container and put back to a Pool . This way, only a few PlayerView instances will be created and reused for as many container/Videos as possible. By default, Kohii has its own logic for creating and recycling PlayerView , but developers can build their own by extending Engine - another important component of Kohii . Extending Engine and building custom playback logic will be discussed in topics for developers.","title":"Reuse PlayerView instance for multiple Videos"},{"location":"advance-summary/","text":"Advance usages \u00b6 Advance usages session will focus on using Kohii with ExoPlayer . Using others extensions will be discussed in more advance topics, because each extension is built with different ability. Here, we assume that you are familiar with ExoPlayer , including its core components (Player, ExoPlayer, SimpleExoPlayer, MediaSource, etc) and UI system (PlayerView, PlayerControlView, ControlDispatcher, etc). This section may use some keywords about components in Kohii like Container , Bucket , etc. You can find their definitions here: Glossary . Advance usages by Kohii : Using custom Kohii creators Using unique tag Show/Hide thumbnail Switching a Video playback between renderers Reuse PlayerView instance for multiple Videos Using MemoryMode to improve UX Playing many Videos at the same time Manual playback","title":"Summary"},{"location":"advance-summary/#advance-usages","text":"Advance usages session will focus on using Kohii with ExoPlayer . Using others extensions will be discussed in more advance topics, because each extension is built with different ability. Here, we assume that you are familiar with ExoPlayer , including its core components (Player, ExoPlayer, SimpleExoPlayer, MediaSource, etc) and UI system (PlayerView, PlayerControlView, ControlDispatcher, etc). This section may use some keywords about components in Kohii like Container , Bucket , etc. You can find their definitions here: Glossary . Advance usages by Kohii : Using custom Kohii creators Using unique tag Show/Hide thumbnail Switching a Video playback between renderers Reuse PlayerView instance for multiple Videos Using MemoryMode to improve UX Playing many Videos at the same time Manual playback","title":"Advance usages"},{"location":"advance-switch-renderer/","text":"Switching a Video playback between renderers \u00b6 In practice, you may find yourself try to bring a Video from a PlayerView to another PlayerView . Doing so can be as simple as calling bind to the destination PlayerView : kohii . setUp ( videoUrl ) { tag = videoTag }. bind ( olayerView1 ) // Later, switch to another `PlayerView` kohii . setUp ( videoUrl ) { tag = videoTag }. bind ( playerView2 ) Note Note that you need to set the same unique tag to the Video, so that after switching to another PlayerView , it keeps playing smoothly, without being reset to beginning. To help you simplify the steps, the call bind(playerView1) with a valid tag will return an object called Rebinder . This Rebinder has one method bind so you can reuse this object to easily rebind a Video to any PlayerView . Rebinder is also a Parcelable , so you can pass this object around. Please check this demo to see how it uses Rebinder to switch a Video from PlayerView to dialog and back.","title":"Switching renderers"},{"location":"advance-switch-renderer/#switching-a-video-playback-between-renderers","text":"In practice, you may find yourself try to bring a Video from a PlayerView to another PlayerView . Doing so can be as simple as calling bind to the destination PlayerView : kohii . setUp ( videoUrl ) { tag = videoTag }. bind ( olayerView1 ) // Later, switch to another `PlayerView` kohii . setUp ( videoUrl ) { tag = videoTag }. bind ( playerView2 ) Note Note that you need to set the same unique tag to the Video, so that after switching to another PlayerView , it keeps playing smoothly, without being reset to beginning. To help you simplify the steps, the call bind(playerView1) with a valid tag will return an object called Rebinder . This Rebinder has one method bind so you can reuse this object to easily rebind a Video to any PlayerView . Rebinder is also a Parcelable , so you can pass this object around. Please check this demo to see how it uses Rebinder to switch a Video from PlayerView to dialog and back.","title":"Switching a Video playback between renderers"},{"location":"advance-thumbnail/","text":"Show/Hide thumbnail \u00b6 Kohii provides a special interface called ArtworkHintListener . With this interface, Kohii can tell client when it should show/hide thumbnail (or artwork in Kohii 's term). Sample code: // 1. Let ViewHolder implement ArtworkHintListener interface. class VideoViewHolder ( itemView : View ): ViewHolder ( itemView ), ArtworkHintListener { val thumbnail : ImageView = // ... this is the ImageView for the thumbnail. // Override this callback to show/hide thumbnail. override fun onArtworkHint ( playback : Playback , shouldShow : Boolean , position : Long , state : Int ) { thumbnail . isVisible = shouldShow } } // 2. Provide the ArtworkHintListener when setting up the Video in ViewHolder kohii . setUp ( assetVideoUri ) { artworkHintListener = this @VideoViewHolder } . bind ( playerView ) You can see this setup in action in this demo . In the callback onArtworkHint , other than a boolean flag shouldShow which is a hint from Kohii about if the artwork should be shown or hidden, there is also position which is the current position of the Video, and state which is current state of the player. Using these values, you can have your own behavior, other than just show/hide the ImageView.","title":"Show/Hide thumbnail"},{"location":"advance-thumbnail/#showhide-thumbnail","text":"Kohii provides a special interface called ArtworkHintListener . With this interface, Kohii can tell client when it should show/hide thumbnail (or artwork in Kohii 's term). Sample code: // 1. Let ViewHolder implement ArtworkHintListener interface. class VideoViewHolder ( itemView : View ): ViewHolder ( itemView ), ArtworkHintListener { val thumbnail : ImageView = // ... this is the ImageView for the thumbnail. // Override this callback to show/hide thumbnail. override fun onArtworkHint ( playback : Playback , shouldShow : Boolean , position : Long , state : Int ) { thumbnail . isVisible = shouldShow } } // 2. Provide the ArtworkHintListener when setting up the Video in ViewHolder kohii . setUp ( assetVideoUri ) { artworkHintListener = this @VideoViewHolder } . bind ( playerView ) You can see this setup in action in this demo . In the callback onArtworkHint , other than a boolean flag shouldShow which is a hint from Kohii about if the artwork should be shown or hidden, there is also position which is the current position of the Video, and state which is current state of the player. Using these values, you can have your own behavior, other than just show/hide the ImageView.","title":"Show/Hide thumbnail"},{"location":"advance-unique-tag/","text":"Using unique tag \u00b6 To have the automatic playback works, you just need this: Kotlin kohii . setUp ( videoUrl ). bind ( playerView ) Java kohii . setUp ( videoUrl ). bind ( playerView ); With this one line, once user scrolls some Videos off screen, and then scrolls them back, the playback position will be reset and the Videos will start from the beginning. If you want the Videos to start from where it was before being scrolled off screen, you need to set an application wide unique tag for the Video. Sample code as below: Kotlin kohii . setUp ( videoUrl ) { tag = videoUniqueTag } . bind ( playerView ) By having a unique tag, your Video state will also be retained across configuration changes like Window size change, orientation change or other system config changes. So it is highly recommended to have unique tags for your Videos. With tag Without tag","title":"Using unique tag"},{"location":"advance-unique-tag/#using-unique-tag","text":"To have the automatic playback works, you just need this: Kotlin kohii . setUp ( videoUrl ). bind ( playerView ) Java kohii . setUp ( videoUrl ). bind ( playerView ); With this one line, once user scrolls some Videos off screen, and then scrolls them back, the playback position will be reset and the Videos will start from the beginning. If you want the Videos to start from where it was before being scrolled off screen, you need to set an application wide unique tag for the Video. Sample code as below: Kotlin kohii . setUp ( videoUrl ) { tag = videoUniqueTag } . bind ( playerView ) By having a unique tag, your Video state will also be retained across configuration changes like Window size change, orientation change or other system config changes. So it is highly recommended to have unique tags for your Videos. With tag Without tag","title":"Using unique tag"},{"location":"changelog/","text":"Change Log \u00b6 [1.4.0.2017001] \u00b6 Changed \u00b6 (kohii-core): Compatible with ExoPlayer 2.17.1. (kohii-core): Target SDK and Compile SDK are updated to 32. (kohii-core): Kotlin 1.6.21. (kohii-exoplayer): ExoPlayer is updated to 2.17.1. Removed \u00b6 (kohii-core): jcenter repository and its usage. [1.3.0.x] \u00b6 This version is skipped. [1.2.0.2011008] \u00b6 Added \u00b6 (kohii-core): Add PlayerPool implementation. (kohii-core): Expose Playback.lock flag. (kohii-exoplayer): Add ExoPlayerPool that extends PlayerPool and replace the ExoPlayerProvider . (kohii-androidx): Add MediaPlayerPool that extends PlayerPool and replace the MediaPlayerProvider . (kohii-ads): Initial implementation using ExoPlayer and Ima Extension API. Changed \u00b6 (kohii-core): Update selection logic. If there is a Playback started manually, the Selector will receive that Playback, otherwise it receives the default candidates. (kohii-exoplayer): ExoPlayer is updated to 2.11.8. (kohii-exoplayer): Use default CacheDataSourceFactory, which uses default fragment size of 5MB. (kohii-exoplayer): DefaultMediaSourceFactoryProvider now accepts nullable DrmSessionManagerProvider. (kohii-exoplayer): Default ExoPlayer implementation will always update the AudioAttributes when the Volume setting is called. (kohii-core): Always use LOW memory mode if system needs it. (#127) (kohii-core): Using ProcessLifecycleOwner instead of screen state broadcast for system-wide toggle the playback. (#125) Removed \u00b6 (kohii-exoplayer): Remove ExoPlayerProvider and its default implementation. (kohii-androidx): Remove MediaPlayerProvider and its default implementation. [1.1.1.2011003] \u00b6 Added \u00b6 Fix an issue that cause cache doesn't write to file ( https://github.com/eneim/kohii/pull/91 ); [1.1.0.2011003] \u00b6 ExoPlayer: 2.11.3 Support multiple playback . Check out docs and recipe for more information. Experimental manual playback. Read more here . Add method Kohii.createControlDispatcher(Playback) . Read more here . Introduce PlayableObserver , Read more here . Introduce activeLifecycleState setting for the Manager. Default to State.STARTED . All the playbacks in a Manager can be played only if the lifecycle state of the Manager is at least this value. Experimental PlayerParameters , NetworkTypeChangeListener : the callback from a NetworkTypeChangeListener needs to return a PlayerParameters value so that the player can switch the video/audio quality, resolution, etc. Deprecate the VideoSize . Its value is no longer used anymore in the library. Experimental initialPlaybackInfo setting for the Binder. Setting this value will allow the Playback to start from a specific PlaybackInfo value. Experimental releaseOnInActive setting for the Binder. Setting this to false will let the Playback keep its state when it is inactive, but not yet detached from the Manager. Add method Playback.Controller.setupRenderer(Playback, Any?) and Playback.Controller.teardownRenderer(Playback, Any?) . Client can configure the renderer with custom manual control logic. Support Playback locking: if a Playback is locked, it will still be selected but will not be played. Add ExoPlayerCache to the kohii-exoplayer package. It can be used to obtain a pre-built Cache easily. Add TrackSelectorFactory , LoadControlFactory to the kohii-exoplayer package. Add ExoPlayerConfig to gather most of the detailed setting for a SimpleExoPlayer instance. Add createKohii convenient methods to easily create Kohii instance with custom parameters. Add Engine.lock* and Engine.unlock* methods to support manual lock/unlock an Activity/Manager/Bucket or Playback. Add a simple demonstration that builds TikTok-alike UI/UX: source code . Another document hub for Kohii: https://www.notion.so/The-Kohii-Library-c89a75e2df2b485391b425b5dc83adce [Breaking] Rename Playable#considerRequestRenderer -> Playable#setupRenderer . [Breaking] Rename Playable#considerReleaseRenderer -> Playable#teardownRenderer . [Breaking] RendererProvider#releaseRenderer now needs to return a boolean. [Breaking] Playback#addCallback and Playback#removeCallback are now internal. [Breaking] The DefaultControlDispatcher is now internal. [Breaking] Include Playback in the ArtworkHintListener#onArtworkHint . [Breaking] Remove default implementations for BandwidthMeterFactory . [1.0.0.2010004] \u00b6 2020.03.15 Open Builder for Kohii and Latte . Clients can now use custom implementations to construct those classes. Example usages: val kohii = Kohii . Builder ( context ) . setPlayableCreator ( customPlayableCreator ) . build () 1.0.0.2010004-beta.5 \u00b6 Experiment release for Bucket.Selector , usage is not finalized yet. Currently it is proved to allow select multiple Playbacks for a Bucket, but finally only one Playback will be picked to play by the Group. Add @JvmOverloads annotation to support calling from Java. Other internal improvements. 1.0.0.2010004-beta.3 \u00b6 2019.12.18 This is the very first release that is documented. Please visit document page for detail. First public beta release.","title":"Changelog"},{"location":"changelog/#change-log","text":"","title":"Change Log"},{"location":"changelog/#1402017001","text":"","title":"[1.4.0.2017001]"},{"location":"changelog/#changed","text":"(kohii-core): Compatible with ExoPlayer 2.17.1. (kohii-core): Target SDK and Compile SDK are updated to 32. (kohii-core): Kotlin 1.6.21. (kohii-exoplayer): ExoPlayer is updated to 2.17.1.","title":"Changed"},{"location":"changelog/#removed","text":"(kohii-core): jcenter repository and its usage.","title":"Removed"},{"location":"changelog/#130x","text":"This version is skipped.","title":"[1.3.0.x]"},{"location":"changelog/#1202011008","text":"","title":"[1.2.0.2011008]"},{"location":"changelog/#added","text":"(kohii-core): Add PlayerPool implementation. (kohii-core): Expose Playback.lock flag. (kohii-exoplayer): Add ExoPlayerPool that extends PlayerPool and replace the ExoPlayerProvider . (kohii-androidx): Add MediaPlayerPool that extends PlayerPool and replace the MediaPlayerProvider . (kohii-ads): Initial implementation using ExoPlayer and Ima Extension API.","title":"Added"},{"location":"changelog/#changed_1","text":"(kohii-core): Update selection logic. If there is a Playback started manually, the Selector will receive that Playback, otherwise it receives the default candidates. (kohii-exoplayer): ExoPlayer is updated to 2.11.8. (kohii-exoplayer): Use default CacheDataSourceFactory, which uses default fragment size of 5MB. (kohii-exoplayer): DefaultMediaSourceFactoryProvider now accepts nullable DrmSessionManagerProvider. (kohii-exoplayer): Default ExoPlayer implementation will always update the AudioAttributes when the Volume setting is called. (kohii-core): Always use LOW memory mode if system needs it. (#127) (kohii-core): Using ProcessLifecycleOwner instead of screen state broadcast for system-wide toggle the playback. (#125)","title":"Changed"},{"location":"changelog/#removed_1","text":"(kohii-exoplayer): Remove ExoPlayerProvider and its default implementation. (kohii-androidx): Remove MediaPlayerProvider and its default implementation.","title":"Removed"},{"location":"changelog/#1112011003","text":"","title":"[1.1.1.2011003]"},{"location":"changelog/#added_1","text":"Fix an issue that cause cache doesn't write to file ( https://github.com/eneim/kohii/pull/91 );","title":"Added"},{"location":"changelog/#1102011003","text":"ExoPlayer: 2.11.3 Support multiple playback . Check out docs and recipe for more information. Experimental manual playback. Read more here . Add method Kohii.createControlDispatcher(Playback) . Read more here . Introduce PlayableObserver , Read more here . Introduce activeLifecycleState setting for the Manager. Default to State.STARTED . All the playbacks in a Manager can be played only if the lifecycle state of the Manager is at least this value. Experimental PlayerParameters , NetworkTypeChangeListener : the callback from a NetworkTypeChangeListener needs to return a PlayerParameters value so that the player can switch the video/audio quality, resolution, etc. Deprecate the VideoSize . Its value is no longer used anymore in the library. Experimental initialPlaybackInfo setting for the Binder. Setting this value will allow the Playback to start from a specific PlaybackInfo value. Experimental releaseOnInActive setting for the Binder. Setting this to false will let the Playback keep its state when it is inactive, but not yet detached from the Manager. Add method Playback.Controller.setupRenderer(Playback, Any?) and Playback.Controller.teardownRenderer(Playback, Any?) . Client can configure the renderer with custom manual control logic. Support Playback locking: if a Playback is locked, it will still be selected but will not be played. Add ExoPlayerCache to the kohii-exoplayer package. It can be used to obtain a pre-built Cache easily. Add TrackSelectorFactory , LoadControlFactory to the kohii-exoplayer package. Add ExoPlayerConfig to gather most of the detailed setting for a SimpleExoPlayer instance. Add createKohii convenient methods to easily create Kohii instance with custom parameters. Add Engine.lock* and Engine.unlock* methods to support manual lock/unlock an Activity/Manager/Bucket or Playback. Add a simple demonstration that builds TikTok-alike UI/UX: source code . Another document hub for Kohii: https://www.notion.so/The-Kohii-Library-c89a75e2df2b485391b425b5dc83adce [Breaking] Rename Playable#considerRequestRenderer -> Playable#setupRenderer . [Breaking] Rename Playable#considerReleaseRenderer -> Playable#teardownRenderer . [Breaking] RendererProvider#releaseRenderer now needs to return a boolean. [Breaking] Playback#addCallback and Playback#removeCallback are now internal. [Breaking] The DefaultControlDispatcher is now internal. [Breaking] Include Playback in the ArtworkHintListener#onArtworkHint . [Breaking] Remove default implementations for BandwidthMeterFactory .","title":"[1.1.0.2011003]"},{"location":"changelog/#1002010004","text":"2020.03.15 Open Builder for Kohii and Latte . Clients can now use custom implementations to construct those classes. Example usages: val kohii = Kohii . Builder ( context ) . setPlayableCreator ( customPlayableCreator ) . build ()","title":"[1.0.0.2010004]"},{"location":"changelog/#1002010004-beta5","text":"Experiment release for Bucket.Selector , usage is not finalized yet. Currently it is proved to allow select multiple Playbacks for a Bucket, but finally only one Playback will be picked to play by the Group. Add @JvmOverloads annotation to support calling from Java. Other internal improvements.","title":"1.0.0.2010004-beta.5"},{"location":"changelog/#1002010004-beta3","text":"2019.12.18 This is the very first release that is documented. Please visit document page for detail. First public beta release.","title":"1.0.0.2010004-beta.3"},{"location":"code_of_conduct/","text":"Contributor Covenant Code of Conduct \u00b6 Our Pledge \u00b6 In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation. Our Standards \u00b6 Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting Our Responsibilities \u00b6 Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful. Scope \u00b6 This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers. Enforcement \u00b6 Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at mr.nguyenhoainam@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership. Attribution \u00b6 This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Code of Conduct"},{"location":"code_of_conduct/#contributor-covenant-code-of-conduct","text":"","title":"Contributor Covenant Code of Conduct"},{"location":"code_of_conduct/#our-pledge","text":"In the interest of fostering an open and welcoming environment, we as contributors and maintainers pledge to making participation in our project and our community a harassment-free experience for everyone, regardless of age, body size, disability, ethnicity, sex characteristics, gender identity and expression, level of experience, education, socio-economic status, nationality, personal appearance, race, religion, or sexual identity and orientation.","title":"Our Pledge"},{"location":"code_of_conduct/#our-standards","text":"Examples of behavior that contributes to creating a positive environment include: Using welcoming and inclusive language Being respectful of differing viewpoints and experiences Gracefully accepting constructive criticism Focusing on what is best for the community Showing empathy towards other community members Examples of unacceptable behavior by participants include: The use of sexualized language or imagery and unwelcome sexual attention or advances Trolling, insulting/derogatory comments, and personal or political attacks Public or private harassment Publishing others' private information, such as a physical or electronic address, without explicit permission Other conduct which could reasonably be considered inappropriate in a professional setting","title":"Our Standards"},{"location":"code_of_conduct/#our-responsibilities","text":"Project maintainers are responsible for clarifying the standards of acceptable behavior and are expected to take appropriate and fair corrective action in response to any instances of unacceptable behavior. Project maintainers have the right and responsibility to remove, edit, or reject comments, commits, code, wiki edits, issues, and other contributions that are not aligned to this Code of Conduct, or to ban temporarily or permanently any contributor for other behaviors that they deem inappropriate, threatening, offensive, or harmful.","title":"Our Responsibilities"},{"location":"code_of_conduct/#scope","text":"This Code of Conduct applies both within project spaces and in public spaces when an individual is representing the project or its community. Examples of representing a project or community include using an official project e-mail address, posting via an official social media account, or acting as an appointed representative at an online or offline event. Representation of a project may be further defined and clarified by project maintainers.","title":"Scope"},{"location":"code_of_conduct/#enforcement","text":"Instances of abusive, harassing, or otherwise unacceptable behavior may be reported by contacting the project team at mr.nguyenhoainam@gmail.com . All complaints will be reviewed and investigated and will result in a response that is deemed necessary and appropriate to the circumstances. The project team is obligated to maintain confidentiality with regard to the reporter of an incident. Further details of specific enforcement policies may be posted separately. Project maintainers who do not follow or enforce the Code of Conduct in good faith may face temporary or permanent repercussions as determined by other members of the project's leadership.","title":"Enforcement"},{"location":"code_of_conduct/#attribution","text":"This Code of Conduct is adapted from the Contributor Covenant , version 1.4, available at https://www.contributor-covenant.org/version/1/4/code-of-conduct.html For answers to common questions about this code of conduct, see https://www.contributor-covenant.org/faq","title":"Attribution"},{"location":"custom-engine/","text":"Custom Engine \u00b6 Document pending","title":"Custom Engine"},{"location":"custom-engine/#custom-engine","text":"Document pending","title":"Custom Engine"},{"location":"demos/","text":"Exploring the demo app \u00b6 Kohii is built with a feature-rich demo application. You can find many recommended ways to use Kohii from them. This session tries to go throw those demos to describe what they do and how to make it in concept. This session will be updated accordingly following the changes of this library. Kohii + RecyclerView \u00b6 Document pending https://ene.im/2020/06/28/kohii-201-videos-in-recyclerview Kohii + TikTok \u00b6 https://ene.im/2020/07/03/clone-tiktok-using-kohii https://www.notion.so/Clone-TikTok-using-Kohii-dc0c254d74544561950ff6309212c183 Kohii + Facebook \u00b6 Document pending","title":"Demo app"},{"location":"demos/#exploring-the-demo-app","text":"Kohii is built with a feature-rich demo application. You can find many recommended ways to use Kohii from them. This session tries to go throw those demos to describe what they do and how to make it in concept. This session will be updated accordingly following the changes of this library.","title":"Exploring the demo app"},{"location":"demos/#kohii-recyclerview","text":"Document pending https://ene.im/2020/06/28/kohii-201-videos-in-recyclerview","title":"Kohii + RecyclerView"},{"location":"demos/#kohii-tiktok","text":"https://ene.im/2020/07/03/clone-tiktok-using-kohii https://www.notion.so/Clone-TikTok-using-Kohii-dc0c254d74544561950ff6309212c183","title":"Kohii + TikTok"},{"location":"demos/#kohii-facebook","text":"Document pending","title":"Kohii + Facebook"},{"location":"design/","text":"Roadmap \u00b6 Basic binding Simple syntax to start binding a Video to a ViewGroup (PlayerView or a ViewGroup that will contain a PlayerView), using Url, Uri or specific Media object. Automatically update the playbacks in RecyclerView, NestedScrollView or general ViewGroup. Automatically update the playbacks in ViewPager, ViewPager2. Callbacks Callbacks for Kohii components status. Callbacks for playback status. (Nice to have) Opinionated callbacks that tell client when it should show/hide thumbnail . Introduce Playback.ArtworkHintListener Handle configuration change Retain playback on configuration changes. Manual control over Playbacks Allow client to have full control over Playbacks: client can start/pause any Playback without the control of system/Kohii. Allow client to have half-manual control over Playbacks: client can start/pause any Playback on demand, but Kohii can also start/pause the Playback regarding some conditions. Global control: simple method to pause/resume everything. The resume behavior follow each Playback\\'s config. Flexible VolumeInfo update mechanism: allow to change VolumeInfo for individual Video or all Videos in the same parent. ExoPlayer related implementations First-class support for playback using ExoPlayer/PlayerView. Cached playback using ExoPlayer cache mechanism. Offline/downloaded playback using ExoPlayer download mechanism. Extensible architecture Base abstraction. Default implementation for ExoPlayer. (Nice to have) Experiment implementation for YouTube Videos using YouTube Player API. (Nice to have) Experiment implementation for YouTube Videos using OSS playback library. (Nice to have) Experiment implementation for AndroidX Media 2. (Nice to have) Experiment implementation for Platform MediaPlayer/VideoView. Others Flag/Callback to enable/disable automatic playback. Useful to trigger the feature on demand (eg: due to Network quality changes). MemoryMode setting, allows client to control how Videos will be kept when it is not playing. For example in HIGH MemoryMode, many Videos can keep resource at the same time, so the playback will be really smooth, but in LOW MemoryMode, any paused Video will be released to save resource. Ads support with Mopub, IMA. Demos Basic RecyclerView sample, no nesting. Basic NestedScrollView sample, no nesting. RecyclerView with NestedScrollView nested in a ViewHolder. RecyclerView with RecyclerView nested in a ViewHolder. NestedScrollView with a RecyclerView nested inside. RecyclerView with user interaction (eg: Click). NestedScrollView with user interaction (eg: Click). ViewPager where pages are PlayerViews or FrameLayouts. ViewPager where pages are RecyclerViews with Videos. (It is recommended to use Fragment with RecyclerView inside ViewPager instead) ViewPager where pages are Fragments contain PlayerViews or FrameLayout. ViewPager where pages are Fragments contain RecyclerView with Videos. ViewPager2 where pages are PlayerViews or FrameLayouts. ViewPager2 where pages are RecyclerViews with Videos. (It is recommended to use Fragment with RecyclerView inside ViewPager instead) ViewPager2 where pages are Fragments contain PlayerViews or FrameLayout. ViewPager2 where pages are Fragments contain RecyclerView with Videos. Multiple Fragments where each contains RecyclerView or ViewPager with Videos. Sample to mimic Facebook. YouTube sample using Android Player SDK (the Official SDK). YouTube sample using PierfrancescoSoffritti/android-youtube-player . Background Playback support Allow configuration to enable/disable background Playback. The config would allow to setup: flag to turn the feature on/off, necessary information for the foreground notification (eg Bitmap for the Notification large image). Allow the Playback to keep playing after closing the App on-demand. Allow the Playback to keep playing when: the Playback is deselected from the Manager, but no newer Playback is selected. Others Store PlaybackInfo to pages + local DB to optimize/reduce in-memory cache. Resource creation \u00b6 Binding Playable to Container (ViewGroup) \u00b6 The actual binding only happens once the Container is attached to Window. The result will be a Playback that has reference to the Container. After being bound, the Container might be detached/re-attached without the need to remove the Playback. States of a Playback: 'ADDED': the binding is established. 'DETACHED': the Container is detached from Window. 'ATTACHED, INACTIVE': the Container is attached to Window, but its visible area is < 0. 'ATTACHED, ACTIVE': the Container is attached to Window, but its visible area is >= 0. 'REMOVED': the binding is destroyed. Lifecycle of a Playback: a Playback lives through the 'ADDED' state and 'REMOVED' state. A 'REMOVED' Playback must also be 'INACTIVE' and 'DETACHED'. Lifecycle of a Playback relies on its Container (ViewGroup)'s lifecycle, the Host that contains that Container and the Manager that contains the Host. Binding scenarios and the behavior: Bind a Playable to a fresh Container: Establish new binding (new Playback will be created and added to the Manager). Any old Playback referenced by Playable must be removed. Bind a Playable to a Container that was bound to different Playable: Establish new binding (new Playback will be created and added to the Manager). Any old Playback referenced by Playable must be removed. Any Playback reference to the same Container must be removed. Bind a Playable to a Container that was bond to the same Playable: no action required. Manager lifecycle and its affects: A Manager lifecycle is bound to its 'origin's lifecycle'. The origin can be ComponentActivity or Fragment. ON_STOP event: all Playbacks must be transferred to up-to 'INACTIVE' state. ON_DESTROY event: all Playbacks must be transferred to up-to 'REMOVED' state. ON_START event: refresh the status of Playbacks to its latest state.","title":"Design"},{"location":"design/#roadmap","text":"Basic binding Simple syntax to start binding a Video to a ViewGroup (PlayerView or a ViewGroup that will contain a PlayerView), using Url, Uri or specific Media object. Automatically update the playbacks in RecyclerView, NestedScrollView or general ViewGroup. Automatically update the playbacks in ViewPager, ViewPager2. Callbacks Callbacks for Kohii components status. Callbacks for playback status. (Nice to have) Opinionated callbacks that tell client when it should show/hide thumbnail . Introduce Playback.ArtworkHintListener Handle configuration change Retain playback on configuration changes. Manual control over Playbacks Allow client to have full control over Playbacks: client can start/pause any Playback without the control of system/Kohii. Allow client to have half-manual control over Playbacks: client can start/pause any Playback on demand, but Kohii can also start/pause the Playback regarding some conditions. Global control: simple method to pause/resume everything. The resume behavior follow each Playback\\'s config. Flexible VolumeInfo update mechanism: allow to change VolumeInfo for individual Video or all Videos in the same parent. ExoPlayer related implementations First-class support for playback using ExoPlayer/PlayerView. Cached playback using ExoPlayer cache mechanism. Offline/downloaded playback using ExoPlayer download mechanism. Extensible architecture Base abstraction. Default implementation for ExoPlayer. (Nice to have) Experiment implementation for YouTube Videos using YouTube Player API. (Nice to have) Experiment implementation for YouTube Videos using OSS playback library. (Nice to have) Experiment implementation for AndroidX Media 2. (Nice to have) Experiment implementation for Platform MediaPlayer/VideoView. Others Flag/Callback to enable/disable automatic playback. Useful to trigger the feature on demand (eg: due to Network quality changes). MemoryMode setting, allows client to control how Videos will be kept when it is not playing. For example in HIGH MemoryMode, many Videos can keep resource at the same time, so the playback will be really smooth, but in LOW MemoryMode, any paused Video will be released to save resource. Ads support with Mopub, IMA. Demos Basic RecyclerView sample, no nesting. Basic NestedScrollView sample, no nesting. RecyclerView with NestedScrollView nested in a ViewHolder. RecyclerView with RecyclerView nested in a ViewHolder. NestedScrollView with a RecyclerView nested inside. RecyclerView with user interaction (eg: Click). NestedScrollView with user interaction (eg: Click). ViewPager where pages are PlayerViews or FrameLayouts. ViewPager where pages are RecyclerViews with Videos. (It is recommended to use Fragment with RecyclerView inside ViewPager instead) ViewPager where pages are Fragments contain PlayerViews or FrameLayout. ViewPager where pages are Fragments contain RecyclerView with Videos. ViewPager2 where pages are PlayerViews or FrameLayouts. ViewPager2 where pages are RecyclerViews with Videos. (It is recommended to use Fragment with RecyclerView inside ViewPager instead) ViewPager2 where pages are Fragments contain PlayerViews or FrameLayout. ViewPager2 where pages are Fragments contain RecyclerView with Videos. Multiple Fragments where each contains RecyclerView or ViewPager with Videos. Sample to mimic Facebook. YouTube sample using Android Player SDK (the Official SDK). YouTube sample using PierfrancescoSoffritti/android-youtube-player . Background Playback support Allow configuration to enable/disable background Playback. The config would allow to setup: flag to turn the feature on/off, necessary information for the foreground notification (eg Bitmap for the Notification large image). Allow the Playback to keep playing after closing the App on-demand. Allow the Playback to keep playing when: the Playback is deselected from the Manager, but no newer Playback is selected. Others Store PlaybackInfo to pages + local DB to optimize/reduce in-memory cache.","title":"Roadmap"},{"location":"design/#resource-creation","text":"","title":"Resource creation"},{"location":"design/#binding-playable-to-container-viewgroup","text":"The actual binding only happens once the Container is attached to Window. The result will be a Playback that has reference to the Container. After being bound, the Container might be detached/re-attached without the need to remove the Playback. States of a Playback: 'ADDED': the binding is established. 'DETACHED': the Container is detached from Window. 'ATTACHED, INACTIVE': the Container is attached to Window, but its visible area is < 0. 'ATTACHED, ACTIVE': the Container is attached to Window, but its visible area is >= 0. 'REMOVED': the binding is destroyed. Lifecycle of a Playback: a Playback lives through the 'ADDED' state and 'REMOVED' state. A 'REMOVED' Playback must also be 'INACTIVE' and 'DETACHED'. Lifecycle of a Playback relies on its Container (ViewGroup)'s lifecycle, the Host that contains that Container and the Manager that contains the Host. Binding scenarios and the behavior: Bind a Playable to a fresh Container: Establish new binding (new Playback will be created and added to the Manager). Any old Playback referenced by Playable must be removed. Bind a Playable to a Container that was bound to different Playable: Establish new binding (new Playback will be created and added to the Manager). Any old Playback referenced by Playable must be removed. Any Playback reference to the same Container must be removed. Bind a Playable to a Container that was bond to the same Playable: no action required. Manager lifecycle and its affects: A Manager lifecycle is bound to its 'origin's lifecycle'. The origin can be ComponentActivity or Fragment. ON_STOP event: all Playbacks must be transferred to up-to 'INACTIVE' state. ON_DESTROY event: all Playbacks must be transferred to up-to 'REMOVED' state. ON_START event: refresh the status of Playbacks to its latest state.","title":"Binding Playable to Container (ViewGroup)"},{"location":"getting-started/","text":"Getting start \u00b6 Kohii is an Android library, therefore to use it, you need to add its artifacts to your module's build.gradle dependency list. Kohii is released the sonatype maven central repository , so before adding Kohii to your project, make sure the following lines exist in your project root build.gradle file: allprojects { repositories { mavenCentral () } } Kohii has the following artifacts: kohii-core This artifact contains core design of the library. It doesn't contain enough implementation detail to start the playback. To do so you need to include one of the following artifacts: kohii-exoplayer This artifact contains the implementation of kohii-core that uses ExoPlayer as playback backend . As a result, you will also need to include necessary ExoPlayer artifacts as well. Your dependency to use kohii-exoplayer will look like below: def kohiiVersion = '1.4.0.2017001' // always use latest available version def exoplayerVersion = '2.17.1' implementation \"im.ene.kohii:kohii-core:${kohiiVersion}\" implementation \"im.ene.kohii:kohii-exoplayer:${kohiiVersion}\" implementation \"com.google.android.exoplayer:exoplayer:${exoplayerVersion}\" Regarding Kohii version name structure Kohii extension for ExoPlayer uses a specific version of ExoPlayer for the playback logic. Because ExoPlayer doesn't guarantee backward compatibility on each minor release, Kohii includes the ExoPlayer release number in its release name to tell developer about which version of ExoPlayer it uses. For example Kohii 1.0.0.2010004 will use ExoPlayer 2.10.4 for playback logic, but Kohii 1.0.0.2011000 will use ExoPlayer 2.11.0 instead. kohii-androidx This artifact contains the implementation of kohii-core that uses AndroidX Media2 as playback backend . As a result, you will also need to include necessary AndroidX Media2 artifacts as well. The setup would be the same as kohii-exoplayer , accept that you need these instead of ExoPlayer : def kohiiVersion = '1.4.0.2017001' // always use latest available version implementation \"im.ene.kohii:kohii-core:${kohiiVersion}\" implementation \"im.ene.kohii:kohii-androidx:${kohiiVersion}\" def media2Version = '1.0.3' implementation \"androidx.media2:media2-widget:${media2Version}\" implementation \"androidx.media2:media2-common:${media2Version}\" implementation \"androidx.media2:media2-player:${media2Version}\" implementation \"androidx.media2:media2-session:${media2Version}\" kohii-experiments This artifacts includes experimental implementations. In short the playback logic provided by this package should be used with caution. Most important things to mention are [1] Kohii doesn't guarantee the compatibility of the experiments, [2] Developers want to adopt these experiments are suggested to copy-paste and modify the code to meet their need. Currently, kohii-experiments provides playback logic for YouTube Playback based on the Official YouTube Android Player API and the Unofficial YouTube Player library for Android and Chromecast . Using this package as below: def kohiiVersion = '1.4.0.2017001' // always use latest available version implementation \"im.ene.kohii:kohii-core:${kohiiVersion}\" implementation \"im.ene.kohii:kohii-experiments:${kohiiVersion}\" Warning Again, please use this package with caution!","title":"Getting start"},{"location":"getting-started/#getting-start","text":"Kohii is an Android library, therefore to use it, you need to add its artifacts to your module's build.gradle dependency list. Kohii is released the sonatype maven central repository , so before adding Kohii to your project, make sure the following lines exist in your project root build.gradle file: allprojects { repositories { mavenCentral () } } Kohii has the following artifacts: kohii-core This artifact contains core design of the library. It doesn't contain enough implementation detail to start the playback. To do so you need to include one of the following artifacts: kohii-exoplayer This artifact contains the implementation of kohii-core that uses ExoPlayer as playback backend . As a result, you will also need to include necessary ExoPlayer artifacts as well. Your dependency to use kohii-exoplayer will look like below: def kohiiVersion = '1.4.0.2017001' // always use latest available version def exoplayerVersion = '2.17.1' implementation \"im.ene.kohii:kohii-core:${kohiiVersion}\" implementation \"im.ene.kohii:kohii-exoplayer:${kohiiVersion}\" implementation \"com.google.android.exoplayer:exoplayer:${exoplayerVersion}\" Regarding Kohii version name structure Kohii extension for ExoPlayer uses a specific version of ExoPlayer for the playback logic. Because ExoPlayer doesn't guarantee backward compatibility on each minor release, Kohii includes the ExoPlayer release number in its release name to tell developer about which version of ExoPlayer it uses. For example Kohii 1.0.0.2010004 will use ExoPlayer 2.10.4 for playback logic, but Kohii 1.0.0.2011000 will use ExoPlayer 2.11.0 instead. kohii-androidx This artifact contains the implementation of kohii-core that uses AndroidX Media2 as playback backend . As a result, you will also need to include necessary AndroidX Media2 artifacts as well. The setup would be the same as kohii-exoplayer , accept that you need these instead of ExoPlayer : def kohiiVersion = '1.4.0.2017001' // always use latest available version implementation \"im.ene.kohii:kohii-core:${kohiiVersion}\" implementation \"im.ene.kohii:kohii-androidx:${kohiiVersion}\" def media2Version = '1.0.3' implementation \"androidx.media2:media2-widget:${media2Version}\" implementation \"androidx.media2:media2-common:${media2Version}\" implementation \"androidx.media2:media2-player:${media2Version}\" implementation \"androidx.media2:media2-session:${media2Version}\" kohii-experiments This artifacts includes experimental implementations. In short the playback logic provided by this package should be used with caution. Most important things to mention are [1] Kohii doesn't guarantee the compatibility of the experiments, [2] Developers want to adopt these experiments are suggested to copy-paste and modify the code to meet their need. Currently, kohii-experiments provides playback logic for YouTube Playback based on the Official YouTube Android Player API and the Unofficial YouTube Player library for Android and Chromecast . Using this package as below: def kohiiVersion = '1.4.0.2017001' // always use latest available version implementation \"im.ene.kohii:kohii-core:${kohiiVersion}\" implementation \"im.ene.kohii:kohii-experiments:${kohiiVersion}\" Warning Again, please use this package with caution!","title":"Getting start"},{"location":"glossary/","text":"Glossary \u00b6 This section helps you to understand the core concepts of Kohii . Renderer and Container \u00b6 When we play a Video to a destination surface, we call that surface a Renderer . Some examples of a Renderer are VideoView in Android framework, PlayerView in ExoPlayer. A component that can contain a Renderer is called Container . If a PlayerView renderer is added directly to a FrameLayout , that FrameLayout is a container. In Kohii , by calling bind(someView) , you are placing your Video to a Container . The renderer can also be the container when it contains itself. Note Currently in Kohii , we only support ViewGroup containers, but theoretically it can be anything. In the future, we will try to expand the concept of container to other types. The idea of Renderer and Container allows Kohii to build the abstractions around them where a renderer can be attached to a container, detached from a container and passed around, and therefore renderers can be reused for unlimited number of Videos. This behavior is supported out of the box by kohii-exoplayer and kohii-androidx packages. Playback and Playable \u00b6 Playback is a component in Kohii , designed to manage the container. Like Fragment in the Android framework which (optionally) has a View and lifecycle , Playback manages a view which is the container, and it has a lifecycle controlled by another component called Manager . A Playback's lifecycle is scoped to the container's lifecycle and the Manager's lifecycle, which is as large as an Activity or a Fragment's lifecycle. When you place a Video in a container by calling bind(container) , Kohii allows you to have some configurations such as tag, delay, visible threshold by which the Video should start or pause, etc. These configurations are passed to the Playback, processed and passed down to lower layer to construct resources for an actual playback. So you can have a Video playing with one configuration in a container, but another configuration in another container. It is helpful when you want to switch a Video playback from list to full-screen and vice-versa. Playable is a component in Kohii , designed to manage the renderer. A Playable is created when the client calls bind(container) , and there is no Playable created previously for the same Video information. In other words, a Playable will be available when there is a Playback requests it. Kohii manages Playable globally, which means that its lifecycle is scoped to the Application lifetime. But once a Playable is no longer needed , it will be destroyed. In Kohii , when a Playable is not used by any Playback, it will be released and scheduled to be destroyed. Though, during transient states like configuration change, current Playback will be destroyed (because its container is destroyed) and new Playback is still under construction, Kohii will give the Playable a few more time to wait for a Playback to request it. After this duration, if a Playable is not requested, Kohii will destroy it to reclaim its memory. The idea of Playable and Playback allows client to use the same Video and player resource for different renderers, which help to reduce the memory usage and enable developers to build complicated scenarios much easier. Bucket, Manager and Group \u00b6 Considering an Application where you have an Activity contains 3 Fragments: A, B and C. A has a RecyclerView (named RA) contains a lot of Videos. B has a ScrollView (named SB) contains many Videos and another RecyclerView (named RB) contains many Videos too. You only want RB to start playing the Videos automatically, and later you want to disable the Video playback of RB and enable it for RA. Kohii makes this possible by using a number of management components: Bucket, Manager and Group. Bucket is a component designed to manage a big View component like RecyclerView , NestedScrollView or ViewPager . Bucket is built by the Manager from the View it manages. And it has the responsibility to tell Manager about UI updates, as well as to select which Video to play from all Videos it knows about. The View is called the root of a Bucket . You can setup any View to be the root of a Bucket. A simple FrameLayout can be the root for a Bucket of all the Renderers it contains. Most of the time you want to use the most suitable root for your use case. For example, in your screen you have a RecyclerView whose each child is a FrameLayout with a PlayerView in it. Either the RecyclerView or each of its FrameLayout children can be the root of a Bucket, but if you want to manage all the Videos at once, you need to use build the Bucket from the RecyclerView. Kohii has built-in factory methods to build Bucket for RecyclerView , NestedScrollView , ViewPager , ViewPager2 and the general ViewGroup . You can have many Bucket in a single screen to enable complicated behavior. For example: when a RecyclerView with many Videos is nested in another RecyclerView, you can build the Bucket for both the RecyclerViews to control the Videos of the nested one. Manager is a component designed to manage a Fragment or an Activity which contains big View*s using Buckets. Manager creates and manages Buckets for Views on demand. You only need to create Bucket for the View whose Video need to be controlled. So in our scenario above, Fragment B only need to register the RecyclerView to **Kohii* , the Manager will then acknowledge this RecyclerView and create a Bucket for it. Manager also manages all Playbacks in all Buckets, and closely communicates with the Group about any UI change. Group is as important as an Activity in Android framework. It contains many Managers just like an Activity can contain many Fragments , and it listens to Managers request to refresh the overall state. Because we will only allow a small number of videos from one Bucket of one Manager at a time to be playing, Group exists to take care of playback state of all Managers , and will carefully update the whole screen (i.e the Activity ) accordingly. Master, Engine \u00b6 Master is the component that controls everything used by the library. In short term, it is the brain of Kohii . There will be only one Master instance exists at one time. It controls the Playable's lifecycle, including destroying them when they are not needed anymore. It manages all the Groups of an Application, dispatch the playback events and so on. The client should never need to access the Master directly. Engine is a component that connects the client with the Master. An Engine has 3 important responsibilities: to initialize other important components like Managers, Groups, to help the client to bind the Video resource to a Container, and to build Playable for the Video. Most of the time, developer only needs to work with the Engine. You can also build custom Engine for your need.","title":"Glossary"},{"location":"glossary/#glossary","text":"This section helps you to understand the core concepts of Kohii .","title":"Glossary"},{"location":"glossary/#renderer-and-container","text":"When we play a Video to a destination surface, we call that surface a Renderer . Some examples of a Renderer are VideoView in Android framework, PlayerView in ExoPlayer. A component that can contain a Renderer is called Container . If a PlayerView renderer is added directly to a FrameLayout , that FrameLayout is a container. In Kohii , by calling bind(someView) , you are placing your Video to a Container . The renderer can also be the container when it contains itself. Note Currently in Kohii , we only support ViewGroup containers, but theoretically it can be anything. In the future, we will try to expand the concept of container to other types. The idea of Renderer and Container allows Kohii to build the abstractions around them where a renderer can be attached to a container, detached from a container and passed around, and therefore renderers can be reused for unlimited number of Videos. This behavior is supported out of the box by kohii-exoplayer and kohii-androidx packages.","title":"Renderer and Container"},{"location":"glossary/#playback-and-playable","text":"Playback is a component in Kohii , designed to manage the container. Like Fragment in the Android framework which (optionally) has a View and lifecycle , Playback manages a view which is the container, and it has a lifecycle controlled by another component called Manager . A Playback's lifecycle is scoped to the container's lifecycle and the Manager's lifecycle, which is as large as an Activity or a Fragment's lifecycle. When you place a Video in a container by calling bind(container) , Kohii allows you to have some configurations such as tag, delay, visible threshold by which the Video should start or pause, etc. These configurations are passed to the Playback, processed and passed down to lower layer to construct resources for an actual playback. So you can have a Video playing with one configuration in a container, but another configuration in another container. It is helpful when you want to switch a Video playback from list to full-screen and vice-versa. Playable is a component in Kohii , designed to manage the renderer. A Playable is created when the client calls bind(container) , and there is no Playable created previously for the same Video information. In other words, a Playable will be available when there is a Playback requests it. Kohii manages Playable globally, which means that its lifecycle is scoped to the Application lifetime. But once a Playable is no longer needed , it will be destroyed. In Kohii , when a Playable is not used by any Playback, it will be released and scheduled to be destroyed. Though, during transient states like configuration change, current Playback will be destroyed (because its container is destroyed) and new Playback is still under construction, Kohii will give the Playable a few more time to wait for a Playback to request it. After this duration, if a Playable is not requested, Kohii will destroy it to reclaim its memory. The idea of Playable and Playback allows client to use the same Video and player resource for different renderers, which help to reduce the memory usage and enable developers to build complicated scenarios much easier.","title":"Playback and Playable"},{"location":"glossary/#bucket-manager-and-group","text":"Considering an Application where you have an Activity contains 3 Fragments: A, B and C. A has a RecyclerView (named RA) contains a lot of Videos. B has a ScrollView (named SB) contains many Videos and another RecyclerView (named RB) contains many Videos too. You only want RB to start playing the Videos automatically, and later you want to disable the Video playback of RB and enable it for RA. Kohii makes this possible by using a number of management components: Bucket, Manager and Group. Bucket is a component designed to manage a big View component like RecyclerView , NestedScrollView or ViewPager . Bucket is built by the Manager from the View it manages. And it has the responsibility to tell Manager about UI updates, as well as to select which Video to play from all Videos it knows about. The View is called the root of a Bucket . You can setup any View to be the root of a Bucket. A simple FrameLayout can be the root for a Bucket of all the Renderers it contains. Most of the time you want to use the most suitable root for your use case. For example, in your screen you have a RecyclerView whose each child is a FrameLayout with a PlayerView in it. Either the RecyclerView or each of its FrameLayout children can be the root of a Bucket, but if you want to manage all the Videos at once, you need to use build the Bucket from the RecyclerView. Kohii has built-in factory methods to build Bucket for RecyclerView , NestedScrollView , ViewPager , ViewPager2 and the general ViewGroup . You can have many Bucket in a single screen to enable complicated behavior. For example: when a RecyclerView with many Videos is nested in another RecyclerView, you can build the Bucket for both the RecyclerViews to control the Videos of the nested one. Manager is a component designed to manage a Fragment or an Activity which contains big View*s using Buckets. Manager creates and manages Buckets for Views on demand. You only need to create Bucket for the View whose Video need to be controlled. So in our scenario above, Fragment B only need to register the RecyclerView to **Kohii* , the Manager will then acknowledge this RecyclerView and create a Bucket for it. Manager also manages all Playbacks in all Buckets, and closely communicates with the Group about any UI change. Group is as important as an Activity in Android framework. It contains many Managers just like an Activity can contain many Fragments , and it listens to Managers request to refresh the overall state. Because we will only allow a small number of videos from one Bucket of one Manager at a time to be playing, Group exists to take care of playback state of all Managers , and will carefully update the whole screen (i.e the Activity ) accordingly.","title":"Bucket, Manager and Group"},{"location":"glossary/#master-engine","text":"Master is the component that controls everything used by the library. In short term, it is the brain of Kohii . There will be only one Master instance exists at one time. It controls the Playable's lifecycle, including destroying them when they are not needed anymore. It manages all the Groups of an Application, dispatch the playback events and so on. The client should never need to access the Master directly. Engine is a component that connects the client with the Master. An Engine has 3 important responsibilities: to initialize other important components like Managers, Groups, to help the client to bind the Video resource to a Container, and to build Playable for the Video. Most of the time, developer only needs to work with the Engine. You can also build custom Engine for your need.","title":"Master, Engine"},{"location":"intro/","text":"TL, DR \u00b6 Kohii is a library that: Is built for Android, supports Android 4.4 (SDK 19) and up. Provides easy to use Video playback functionality, including automatic playback, playback continuity across config change, lifecycle change and more. By default, support ExoPlayer and any ViewGroup as the bucket for videos, including: RecyclerView, NestedScrollView, ViewPager, ViewPager2, general ViewGroup, etc Kohii provides following features by default: Full automatic playback control using ExoPlayer as playback framework. Semi manual playback control using ExoPlayer as playback framework. User can play/pause specific player on demand, Kohii will smartly pause the Video if it is not visible anymore, and restore the previous state later if needed. Full manual playback control using ExoPlayer as playback framework. User can play/pause specific player on demand, Kohii does not touch anything, but take care of cleaning resource if needed (eg: release Player instances after user closes the Application). Preserve playback continuity across configuration changes, lifecycle changes (eg: from Activity to Activity) using ExoPlayer as playback framework. This means: rotating the device, switching to multi-windows mode or opening full-screen player doesn\\'t trigger pausing/resuming the playback. While the visual part will be re-rendered (due to View recreation), the audio part is kept smoothly, provide continuous playback experience. Reuse PlayerView instances for many players. Thinking that playing thousands of videos in sequence just using one PlayerView instance . Scoped volume configuration. This means: you can set volume value of one Video, and apply the same for others, depending on the scope you want. The scope can be just that Video, or all Videos in the same RecyclerView/ScrollView , or all Videos in the same Activity . Rich features demo app: demo and guidelines for creating various UX/UI patterns, from simple to complicated, including Picture-In-Picture playback or Scroll-To-Mini-Player UX just like YouTube app. For advance developers Kohii API is highly abstracted. You can easily extend it to support non-ExoPlayer API, or more complicated playback API. There is demo on how to use this YouTube player library in Kohii. The idea of Playback Continuity \u00b6 The concept Playback Continuity comes when I prepared for the Tokyo DroidKaigi 2019 where I will also talk about the same topic. Its idea was in my mind for a long time ago. Thinking about a Video playback, what are the common scenarios: Single, individual playback, like watching a movie on Netflix or YouTube. Multiple playback, like viewing many videos on a timeline like Facebook, and watch them one by one while scrolling through the list. All of these scenarios must share some common behaviors: Features \u00b6 0. Rich feature demo application \u00b6 As always, I try to cover as much of the capabilities of the library as possible in the demo app. By that, you can have the recommended ways to implement many patterns using Kohii , including: Using Kohii in RecyclerView only (the simplest pattern). Using Kohii in NestedScrollView only (yes, Kohii does not just support RecyclerView, it works with any ViewGroup you can imagine of, or, most of them). Using Kohii in ViewPager only, where each page is a Fragment (this is one of the thing that toro could not support well, so Kohii is here for the rescue). Using Kohii in Master/Detail UI composition (this is a new pattern I\\'m experimenting with, and it needs time to be battle proof, and it needs your feedback to be mature <3). Using Kohii in RecyclerView, with 'click-to-fullscreen' feature like YouTube UI. This is the game changer, my selling point for Kohii <3. Implementation of it is also discussed in this post . Using Kohii in RecyclerView, with 'click-to-fullscreen' feature that open the fullscreen playback in new Activity , without pausing/resuming the playback . So starting new Activity for fullscreen player will not interrupt your playback UX, sounds good huh? Using Kohii in RecyclerView, with 'click-to-fullscreen' feature that open the fullscreen playback in new Fragment , because single Activity is the new trend. To make it more fun, I also add the fragment transition learnt from here . And more to come, depending on the feedback I got, request I receive and time I have to spend. 1. Few-line setup, full auto \u00b6 Thinking that you just need the following lines to integrate fully automatic Video playback in to your App: // Init Kohii for Fragment or Activity val kohii = Kohii [ this /* fragment or activity instance */ ] kohii . register ( this , arrayOf ( recyclerView )) // register the RecyclerView to be a 'host' of our Videos. // In ViewHolder or Adapter's onBindViewHolder, where kohii instance is passed from above kohii . setUp ( videoUrl ). bind ( playerView ) // playerView is instance of ExoPlayer's PlayerView. This is the fastest way to use Kohii . With this setup, you got: Videos will be played/paused automatically on user's scroll. The top-most PlayerView whose visible area is equal to, or more than 65% of its area will be the one to play, all other PlayerView instances will be paused. Configuration changes like multi-windows mode, orientation change etc will not interupt the playback. (As the matter of fact, SurfaceView or TextureView used in PlayerView will be recreated, so you will see the glitch of the Video image frame, but the Audio will keep playing during the configuration change). Under the hood: Resource for Video playback is initialized as late as possible, so there is little to no impact to app's UX. Resource for Video playback is cached for reusability, so playback switching will be as fast as possible. Cached resource will be released as soon as possible, so there is no concern about memory leak. All playback logic, ExoPlayer implementation are provided by Kohii. You don't need to worry about anything. Digging in the API, you will have more control over the playback behavior, including: Repeat mode, which is the same with that of ExoPlayer. Delay, which help you to start the Playback with an amount of delay. Visible area of the PlayerView that trigger the playback. It is 65% by default, but you are free to change it. Initial playback info, so you can control the starting position, volume of a playback. And more. 2. Reusing PlayerView instance, with the same amount of code \u00b6 Yes, you read it correctly. Now you can reuse PlayerView instance across many Video playback. This is something toro could not archive, due to the limitation of its design. And as it is highly requested , Kohii is my answer to the problem. Changing the setup before to this // Init Kohii for Fragment or Activity val kohii = Kohii [ this /* fragment or activity instance */ ] kohii . register ( this , arrayOf ( recyclerView )) // register the RecyclerView to be a 'host' of our Videos. // In ViewHolder or Adapter's onBindViewHolder, where kohii instance is passed from above kohii . setUp ( videoUrl ). bind ( playerViewContainer ) // playerViewContainer is a ViewGroup to put PlayerView instance on demand. Just changing from using a PlayerView instance directly to using a container , you are done. To help you understand this feature, let\\'s talk about the why real quick: why reusing PlayerView instance is that cool? . If you take a look on the issue I mention above , go from bottom-up because it is a long issue to read through, you can see the discussion about reusing stuff in the ExoPlayer & RecyclerView combination . Yes, it is important to reuse as much as possible, to keep a smooth user experience, as well as to save memory. Assuming that you use PlayerView in your ViewHolder to play the video. If your viewport has 3 ~ 4 ViewHolders that contains Video, there will be at most one PlayerView that is playing at a time, and at least 2 ~ 3 PlayerView instances doing nothing, but still keeping an expensive Surface object alive. We know that creating and keeping Surface are expensive operations, so reusing the Surface is a reasonable requirement. How Kohii supports this: The required step is client provides the container to Kohii using the code above. The container can be just a FrameLayout. Kohii keeps a pool of PlayerView that will create the PlayerView instance on demand, and keep the cache of up to 2 instances of it, in the Activity's lifecycle scope. So once the Activity is destroyed, the pool is automatically cleared, again, no fear of memory leak. Kohii knows when the PlayerView should appear, and when it should not . When the PlayerView is demanded, Kohii acquires one instance from the pool. If there is no cached instance, a new instance will be created. On one hand, this instance will be passed to the playback engine, and on the other hand, it will be added to the container by internal mechanism. When the PlayerView should disappear, Kohii will remove it from the container , and release it back to the pool for reuse. Because there will be at most one PlayerView to play at a time, and Kohii's pool keeps up to 2 instances at a time, there will be at most 2 PlayerView instances living at a moment. (In practice, depends on how complicated your video content is, there will be more. For example you have both DRM content and non-DRM content, and you want to use TextureView for non-DRM ones, then Kohii keeps 2 pools for 2 types of playback). The caveat of this mechanism is that by default you do not control the way a PlayerView is created (spoiler: with more lines of code, you can). With more advance setup, you have the following control: How to add and remove PlayerView instance to/from the container . Because your container may contains other Views, Kohii allows you to provide your way to handle this operation. How to create PlayerView instance, because you may have your custom PlayerView implementation. 3. Manual control \u00b6 Some of the requirement I got from toro are the abilities to: Manually control the playback using UI/buttons Mute/Un-mute one playback and apply that to all Those 2 control can be gathered in one group: manual playback control, with scope. Kohii provides the following behaviors to make it possible: Allow client to configure so that, user can fully control the video playback, without any help by Kohii. For instance: when your RecyclerView is shown, and the first ViewHolder is a Video and it is fully visible. This behavior will not start the playback automatically, user can start/pause/do anything with the playback using client-provide UI controller. Once user scrolls the Video so that it is no longer visible on screen, Kohii will not do anything to pause or release the playback. If it was playing before, it keeps playing. If it was paused before, it keeps being paused. But once the Activity that contains this playback is destroyed, Kohii will correctly clear any resource in use. And even better, the manual playback is retained across configuration change, without any interuption. Allow client to configure so that, user can control the playback on the fly. This means that: Kohii will still start the playback automatically, but once user click to some buttons to pause it, Kohii will not change that state. So a video paused by user, even if it is fully visible, will not be played automatically (in full-auto config, Kohii will start this playback). When user scrolls the Video so that it is no longer visible enough, Kohii will do its jobs to pause and release resource if needed. And when user scrolls the Video back to visible enough, Kohii will put the playback to its previous state: if it was playing before being scrolled off-screen, it will be resumed; if it was paused before being scrolled off-screen, it keeps being paused. About the volume control, it works in a bit different way: Kohii allows client to apply a volume value by scope . There are 4 scopes in Kohii, but to not go too deep, I will just talk about 2: playback scope, and global scope. If client applies a volume value to playback scope , then only the receiver playback object will have this new volume value. But if client applies a volume value to global scope , then all currently playing playbacks, and any playback that will be created next will have the new volume value. The control flow is easy to imagine, but not easy to implementation. What I did for Kohii is one of my best thing I have ever done. And I hope it helps you to solve your problems.","title":"Intro"},{"location":"intro/#tl-dr","text":"Kohii is a library that: Is built for Android, supports Android 4.4 (SDK 19) and up. Provides easy to use Video playback functionality, including automatic playback, playback continuity across config change, lifecycle change and more. By default, support ExoPlayer and any ViewGroup as the bucket for videos, including: RecyclerView, NestedScrollView, ViewPager, ViewPager2, general ViewGroup, etc Kohii provides following features by default: Full automatic playback control using ExoPlayer as playback framework. Semi manual playback control using ExoPlayer as playback framework. User can play/pause specific player on demand, Kohii will smartly pause the Video if it is not visible anymore, and restore the previous state later if needed. Full manual playback control using ExoPlayer as playback framework. User can play/pause specific player on demand, Kohii does not touch anything, but take care of cleaning resource if needed (eg: release Player instances after user closes the Application). Preserve playback continuity across configuration changes, lifecycle changes (eg: from Activity to Activity) using ExoPlayer as playback framework. This means: rotating the device, switching to multi-windows mode or opening full-screen player doesn\\'t trigger pausing/resuming the playback. While the visual part will be re-rendered (due to View recreation), the audio part is kept smoothly, provide continuous playback experience. Reuse PlayerView instances for many players. Thinking that playing thousands of videos in sequence just using one PlayerView instance . Scoped volume configuration. This means: you can set volume value of one Video, and apply the same for others, depending on the scope you want. The scope can be just that Video, or all Videos in the same RecyclerView/ScrollView , or all Videos in the same Activity . Rich features demo app: demo and guidelines for creating various UX/UI patterns, from simple to complicated, including Picture-In-Picture playback or Scroll-To-Mini-Player UX just like YouTube app. For advance developers Kohii API is highly abstracted. You can easily extend it to support non-ExoPlayer API, or more complicated playback API. There is demo on how to use this YouTube player library in Kohii.","title":"TL, DR"},{"location":"intro/#the-idea-of-playback-continuity","text":"The concept Playback Continuity comes when I prepared for the Tokyo DroidKaigi 2019 where I will also talk about the same topic. Its idea was in my mind for a long time ago. Thinking about a Video playback, what are the common scenarios: Single, individual playback, like watching a movie on Netflix or YouTube. Multiple playback, like viewing many videos on a timeline like Facebook, and watch them one by one while scrolling through the list. All of these scenarios must share some common behaviors:","title":"The idea of Playback Continuity"},{"location":"intro/#features","text":"","title":"Features"},{"location":"intro/#0-rich-feature-demo-application","text":"As always, I try to cover as much of the capabilities of the library as possible in the demo app. By that, you can have the recommended ways to implement many patterns using Kohii , including: Using Kohii in RecyclerView only (the simplest pattern). Using Kohii in NestedScrollView only (yes, Kohii does not just support RecyclerView, it works with any ViewGroup you can imagine of, or, most of them). Using Kohii in ViewPager only, where each page is a Fragment (this is one of the thing that toro could not support well, so Kohii is here for the rescue). Using Kohii in Master/Detail UI composition (this is a new pattern I\\'m experimenting with, and it needs time to be battle proof, and it needs your feedback to be mature <3). Using Kohii in RecyclerView, with 'click-to-fullscreen' feature like YouTube UI. This is the game changer, my selling point for Kohii <3. Implementation of it is also discussed in this post . Using Kohii in RecyclerView, with 'click-to-fullscreen' feature that open the fullscreen playback in new Activity , without pausing/resuming the playback . So starting new Activity for fullscreen player will not interrupt your playback UX, sounds good huh? Using Kohii in RecyclerView, with 'click-to-fullscreen' feature that open the fullscreen playback in new Fragment , because single Activity is the new trend. To make it more fun, I also add the fragment transition learnt from here . And more to come, depending on the feedback I got, request I receive and time I have to spend.","title":"0. Rich feature demo application"},{"location":"intro/#1-few-line-setup-full-auto","text":"Thinking that you just need the following lines to integrate fully automatic Video playback in to your App: // Init Kohii for Fragment or Activity val kohii = Kohii [ this /* fragment or activity instance */ ] kohii . register ( this , arrayOf ( recyclerView )) // register the RecyclerView to be a 'host' of our Videos. // In ViewHolder or Adapter's onBindViewHolder, where kohii instance is passed from above kohii . setUp ( videoUrl ). bind ( playerView ) // playerView is instance of ExoPlayer's PlayerView. This is the fastest way to use Kohii . With this setup, you got: Videos will be played/paused automatically on user's scroll. The top-most PlayerView whose visible area is equal to, or more than 65% of its area will be the one to play, all other PlayerView instances will be paused. Configuration changes like multi-windows mode, orientation change etc will not interupt the playback. (As the matter of fact, SurfaceView or TextureView used in PlayerView will be recreated, so you will see the glitch of the Video image frame, but the Audio will keep playing during the configuration change). Under the hood: Resource for Video playback is initialized as late as possible, so there is little to no impact to app's UX. Resource for Video playback is cached for reusability, so playback switching will be as fast as possible. Cached resource will be released as soon as possible, so there is no concern about memory leak. All playback logic, ExoPlayer implementation are provided by Kohii. You don't need to worry about anything. Digging in the API, you will have more control over the playback behavior, including: Repeat mode, which is the same with that of ExoPlayer. Delay, which help you to start the Playback with an amount of delay. Visible area of the PlayerView that trigger the playback. It is 65% by default, but you are free to change it. Initial playback info, so you can control the starting position, volume of a playback. And more.","title":"1. Few-line setup, full auto"},{"location":"intro/#2-reusing-playerview-instance-with-the-same-amount-of-code","text":"Yes, you read it correctly. Now you can reuse PlayerView instance across many Video playback. This is something toro could not archive, due to the limitation of its design. And as it is highly requested , Kohii is my answer to the problem. Changing the setup before to this // Init Kohii for Fragment or Activity val kohii = Kohii [ this /* fragment or activity instance */ ] kohii . register ( this , arrayOf ( recyclerView )) // register the RecyclerView to be a 'host' of our Videos. // In ViewHolder or Adapter's onBindViewHolder, where kohii instance is passed from above kohii . setUp ( videoUrl ). bind ( playerViewContainer ) // playerViewContainer is a ViewGroup to put PlayerView instance on demand. Just changing from using a PlayerView instance directly to using a container , you are done. To help you understand this feature, let\\'s talk about the why real quick: why reusing PlayerView instance is that cool? . If you take a look on the issue I mention above , go from bottom-up because it is a long issue to read through, you can see the discussion about reusing stuff in the ExoPlayer & RecyclerView combination . Yes, it is important to reuse as much as possible, to keep a smooth user experience, as well as to save memory. Assuming that you use PlayerView in your ViewHolder to play the video. If your viewport has 3 ~ 4 ViewHolders that contains Video, there will be at most one PlayerView that is playing at a time, and at least 2 ~ 3 PlayerView instances doing nothing, but still keeping an expensive Surface object alive. We know that creating and keeping Surface are expensive operations, so reusing the Surface is a reasonable requirement. How Kohii supports this: The required step is client provides the container to Kohii using the code above. The container can be just a FrameLayout. Kohii keeps a pool of PlayerView that will create the PlayerView instance on demand, and keep the cache of up to 2 instances of it, in the Activity's lifecycle scope. So once the Activity is destroyed, the pool is automatically cleared, again, no fear of memory leak. Kohii knows when the PlayerView should appear, and when it should not . When the PlayerView is demanded, Kohii acquires one instance from the pool. If there is no cached instance, a new instance will be created. On one hand, this instance will be passed to the playback engine, and on the other hand, it will be added to the container by internal mechanism. When the PlayerView should disappear, Kohii will remove it from the container , and release it back to the pool for reuse. Because there will be at most one PlayerView to play at a time, and Kohii's pool keeps up to 2 instances at a time, there will be at most 2 PlayerView instances living at a moment. (In practice, depends on how complicated your video content is, there will be more. For example you have both DRM content and non-DRM content, and you want to use TextureView for non-DRM ones, then Kohii keeps 2 pools for 2 types of playback). The caveat of this mechanism is that by default you do not control the way a PlayerView is created (spoiler: with more lines of code, you can). With more advance setup, you have the following control: How to add and remove PlayerView instance to/from the container . Because your container may contains other Views, Kohii allows you to provide your way to handle this operation. How to create PlayerView instance, because you may have your custom PlayerView implementation.","title":"2. Reusing PlayerView instance, with the same amount of code"},{"location":"intro/#3-manual-control","text":"Some of the requirement I got from toro are the abilities to: Manually control the playback using UI/buttons Mute/Un-mute one playback and apply that to all Those 2 control can be gathered in one group: manual playback control, with scope. Kohii provides the following behaviors to make it possible: Allow client to configure so that, user can fully control the video playback, without any help by Kohii. For instance: when your RecyclerView is shown, and the first ViewHolder is a Video and it is fully visible. This behavior will not start the playback automatically, user can start/pause/do anything with the playback using client-provide UI controller. Once user scrolls the Video so that it is no longer visible on screen, Kohii will not do anything to pause or release the playback. If it was playing before, it keeps playing. If it was paused before, it keeps being paused. But once the Activity that contains this playback is destroyed, Kohii will correctly clear any resource in use. And even better, the manual playback is retained across configuration change, without any interuption. Allow client to configure so that, user can control the playback on the fly. This means that: Kohii will still start the playback automatically, but once user click to some buttons to pause it, Kohii will not change that state. So a video paused by user, even if it is fully visible, will not be played automatically (in full-auto config, Kohii will start this playback). When user scrolls the Video so that it is no longer visible enough, Kohii will do its jobs to pause and release resource if needed. And when user scrolls the Video back to visible enough, Kohii will put the playback to its previous state: if it was playing before being scrolled off-screen, it will be resumed; if it was paused before being scrolled off-screen, it keeps being paused. About the volume control, it works in a bit different way: Kohii allows client to apply a volume value by scope . There are 4 scopes in Kohii, but to not go too deep, I will just talk about 2: playback scope, and global scope. If client applies a volume value to playback scope , then only the receiver playback object will have this new volume value. But if client applies a volume value to global scope , then all currently playing playbacks, and any playback that will be created next will have the new volume value. The control flow is easy to imagine, but not easy to implementation. What I did for Kohii is one of my best thing I have ever done. And I hope it helps you to solve your problems.","title":"3. Manual control"},{"location":"usage-basic/","text":"Basic usages \u00b6 The scenario \u00b6 This basic usage session will guide you step-by-step to complete this scenario: you have a Fragment with many Videos in a vertical RecyclerView . You want each Video to start playing automatically if that Video is visible more than 65% of its full area, and stay on top of all the visible Videos (fully, or partly) . If you scroll the list, the Video that is not visible enough will be paused automatically, and the other Video which sastisfy the condition above will start playing automatically. TL,DR \u00b6 We will explains a lot of details, so it may be a lot of texts. Here is the short version if you want to start right away: First, add this to your Fragment#onViewCreated or Activity#onCreate Kotlin val kohii = Kohii [ this ] kohii . register ( this ) . addBucket ( recyclerView ) // assume that you are using a RecyclerView . addBucket ( anotherRecyclerView ) // yeah, 2 RVs in one place, why not. Java Kohii kohii = Kohii . get ( this ); kohii . register ( this ) . addBucket ( recyclerView ) // assume that you are using a RecyclerView . addBucket ( anotherRecyclerView ); // yeah, 2 RVs in one place, why not. Second, add this in your RecyclerView.Adapter#onBindViewHolder , or corresponding place in ViewHolder Kotlin // You need to pass the kohii instance here kohii . setUp ( videoUrl ). bind ( playerView ) Java // You need to pass the kohii instance here kohii . setUp ( videoUrl ). bind ( playerView ); Done, you have what you want. But before leaving, let's discover the details below with your curiousity. Before you start: thinking in Kohii \u00b6 It is important that you get the concept of Kohii before we go further. Because the way you think about Video playback until now would be different to what Kohii thinks. Until now, you may see and/or use the following pattern: videoView . setVideoPath ( videoUrl ) This line reads : I have a VideoView and I will play a Video in it by calling setVideoPath method. In Kohii , the direction is opposite: kohii . setUp ( videoUrl ). bind ( videoView ) This line reads: I have a Video and I will play it in a VideoView. Let's setup the Video and bind it to the VideoView. The difference here is: who is the main actor ? In traditional way, the VideoView owns the Video and therefore, when it dies, we also lose the Video playback. In Kohii , we let the Video be the active part. It acknowledges the VideoView it will be played on. So when the VideoView dies, your Video can be smoothly switched to other VideoView . To give you an imagine about why it is good this way, consider this scenario: you have a list of Videos, and you want to open one Video in fullscreen, smoothly . Thinking in traditional way : How I can open this VideoView (which is now in the list) in fullscreen? If I use other VideoView I will need to call that setVideoPath again and it will create new resource and stuff and the playback will be reloaded, and so on... We see some challenges here already. While thinking in Kohii way , it sounds easier: How can I open this Video (which is now in the list) in fullscreen? Can I just switch it from current VideoView to the fullscreen VideoView ? This way of thinking is the base for all the abstractions in Kohii . How this idea comes to life will be discussed later. Now that you have the concept about Kohii , let's get our hands dirty. Preparation \u00b6 This section will use some assumptions below: You will use Kohii in Fragment (the usage will be the same in Activity ). You use ExoPlayer for the playback (implementation provided via kohii-exoplayer extension). You own the content or have enough rights to use them. Kohii has no responsibility about how you use it in your app. First, you need to initialize a few things so that Kohii makes sense of your application. \u25a0 Initialize Kohii instance Kohii should be used as a Global instance. You can get it as follow: Kotlin val kohii = Kohii [ this @Fragment ] // or using Context also works: val kohii = Kohii[requireContext()] Java Kohii kohii = Kohii . get ( this ); // or using Context: Kohii kohii = Kohii.get(requireContext()); As a singleton , Kohii instance can be passed around or re-obtained in other Fragment . You can also use dependency injection library like Dagger to prepare a global instance, and inject it to required places. \u25a0 Register necessary objects to Kohii Kohii needs to know about a few things to work properly: Where you are using Kohii from? A Fragment or Activity ? Line below answers that question: Kotlin // From the Fragment's onViewCreated() kohii . register ( this @Fragment ) Java // From the Fragment's onViewCreated() kohii . register ( this ); The line above also return a Manager object. It is useful in some advance usages, but we don't need it for now. Which ViewGroup contains Videos? We call that ViewGroup a Bucket . Because you may have more than one bucket in your Fragment , and not all of them need to be tracked by Kohii , you should only register ones you care about. Code for it is as below: Kotlin kohii . register ( this @Fragment ) // or manager . addBucket ( recyclerView ) . addBucket ( anotherRecyclerView ) // yeah, 2 RVs in one Fragment, why not. Java kohii . register ( this ) // or manager . addBucket ( recyclerView ) . addBucket ( anotherRecyclerView ); // yeah, 2 RVs in one Fragment, why not. It is enough setting up for this session. Next, we will setup the Video for each ViewHolder. Integration \u00b6 To make it works, you need only one line: Kotlin // You must pass the kohii instance here // playerView is the PlayerView you want to play your Video on kohii . setUp ( videoUrl ). bind ( playerView ) Java // You must pass the kohii instance here // playerView is the PlayerView you want to play your Video on kohii . setUp ( videoUrl ). bind ( playerView ); But let's understand the concept behind: In the one line above: kohii.setUp(videoUrl) turns the url to a Binder object which can be used to bind to a container . Once you finish the setup, you have the Video to be automatically played/paused once user scrolls the list such that the container is visible more (will play) or less (will pause) than 65% of its area. Also, to ensure the playback is automatic, if the renderer is a PlayerView Kohii will forcefully disable the PlayerView 's PlayerControlView even if you set it before. To have manual playback control enabled, you need some additional configuration which will be discussed in other session.","title":"Basic usages"},{"location":"usage-basic/#basic-usages","text":"","title":"Basic usages"},{"location":"usage-basic/#the-scenario","text":"This basic usage session will guide you step-by-step to complete this scenario: you have a Fragment with many Videos in a vertical RecyclerView . You want each Video to start playing automatically if that Video is visible more than 65% of its full area, and stay on top of all the visible Videos (fully, or partly) . If you scroll the list, the Video that is not visible enough will be paused automatically, and the other Video which sastisfy the condition above will start playing automatically.","title":"The scenario"},{"location":"usage-basic/#tldr","text":"We will explains a lot of details, so it may be a lot of texts. Here is the short version if you want to start right away: First, add this to your Fragment#onViewCreated or Activity#onCreate Kotlin val kohii = Kohii [ this ] kohii . register ( this ) . addBucket ( recyclerView ) // assume that you are using a RecyclerView . addBucket ( anotherRecyclerView ) // yeah, 2 RVs in one place, why not. Java Kohii kohii = Kohii . get ( this ); kohii . register ( this ) . addBucket ( recyclerView ) // assume that you are using a RecyclerView . addBucket ( anotherRecyclerView ); // yeah, 2 RVs in one place, why not. Second, add this in your RecyclerView.Adapter#onBindViewHolder , or corresponding place in ViewHolder Kotlin // You need to pass the kohii instance here kohii . setUp ( videoUrl ). bind ( playerView ) Java // You need to pass the kohii instance here kohii . setUp ( videoUrl ). bind ( playerView ); Done, you have what you want. But before leaving, let's discover the details below with your curiousity.","title":"TL,DR"},{"location":"usage-basic/#before-you-start-thinking-in-kohii","text":"It is important that you get the concept of Kohii before we go further. Because the way you think about Video playback until now would be different to what Kohii thinks. Until now, you may see and/or use the following pattern: videoView . setVideoPath ( videoUrl ) This line reads : I have a VideoView and I will play a Video in it by calling setVideoPath method. In Kohii , the direction is opposite: kohii . setUp ( videoUrl ). bind ( videoView ) This line reads: I have a Video and I will play it in a VideoView. Let's setup the Video and bind it to the VideoView. The difference here is: who is the main actor ? In traditional way, the VideoView owns the Video and therefore, when it dies, we also lose the Video playback. In Kohii , we let the Video be the active part. It acknowledges the VideoView it will be played on. So when the VideoView dies, your Video can be smoothly switched to other VideoView . To give you an imagine about why it is good this way, consider this scenario: you have a list of Videos, and you want to open one Video in fullscreen, smoothly . Thinking in traditional way : How I can open this VideoView (which is now in the list) in fullscreen? If I use other VideoView I will need to call that setVideoPath again and it will create new resource and stuff and the playback will be reloaded, and so on... We see some challenges here already. While thinking in Kohii way , it sounds easier: How can I open this Video (which is now in the list) in fullscreen? Can I just switch it from current VideoView to the fullscreen VideoView ? This way of thinking is the base for all the abstractions in Kohii . How this idea comes to life will be discussed later. Now that you have the concept about Kohii , let's get our hands dirty.","title":"Before you start: thinking in Kohii"},{"location":"usage-basic/#preparation","text":"This section will use some assumptions below: You will use Kohii in Fragment (the usage will be the same in Activity ). You use ExoPlayer for the playback (implementation provided via kohii-exoplayer extension). You own the content or have enough rights to use them. Kohii has no responsibility about how you use it in your app. First, you need to initialize a few things so that Kohii makes sense of your application. \u25a0 Initialize Kohii instance Kohii should be used as a Global instance. You can get it as follow: Kotlin val kohii = Kohii [ this @Fragment ] // or using Context also works: val kohii = Kohii[requireContext()] Java Kohii kohii = Kohii . get ( this ); // or using Context: Kohii kohii = Kohii.get(requireContext()); As a singleton , Kohii instance can be passed around or re-obtained in other Fragment . You can also use dependency injection library like Dagger to prepare a global instance, and inject it to required places. \u25a0 Register necessary objects to Kohii Kohii needs to know about a few things to work properly: Where you are using Kohii from? A Fragment or Activity ? Line below answers that question: Kotlin // From the Fragment's onViewCreated() kohii . register ( this @Fragment ) Java // From the Fragment's onViewCreated() kohii . register ( this ); The line above also return a Manager object. It is useful in some advance usages, but we don't need it for now. Which ViewGroup contains Videos? We call that ViewGroup a Bucket . Because you may have more than one bucket in your Fragment , and not all of them need to be tracked by Kohii , you should only register ones you care about. Code for it is as below: Kotlin kohii . register ( this @Fragment ) // or manager . addBucket ( recyclerView ) . addBucket ( anotherRecyclerView ) // yeah, 2 RVs in one Fragment, why not. Java kohii . register ( this ) // or manager . addBucket ( recyclerView ) . addBucket ( anotherRecyclerView ); // yeah, 2 RVs in one Fragment, why not. It is enough setting up for this session. Next, we will setup the Video for each ViewHolder.","title":"Preparation"},{"location":"usage-basic/#integration","text":"To make it works, you need only one line: Kotlin // You must pass the kohii instance here // playerView is the PlayerView you want to play your Video on kohii . setUp ( videoUrl ). bind ( playerView ) Java // You must pass the kohii instance here // playerView is the PlayerView you want to play your Video on kohii . setUp ( videoUrl ). bind ( playerView ); But let's understand the concept behind: In the one line above: kohii.setUp(videoUrl) turns the url to a Binder object which can be used to bind to a container . Once you finish the setup, you have the Video to be automatically played/paused once user scrolls the list such that the container is visible more (will play) or less (will pause) than 65% of its area. Also, to ensure the playback is automatic, if the renderer is a PlayerView Kohii will forcefully disable the PlayerView 's PlayerControlView even if you set it before. To have manual playback control enabled, you need some additional configuration which will be discussed in other session.","title":"Integration"}]}